import { Connection } from 'zcatalyst-sdk-node/lib/connector/connection';
import { ICatalystCache, ICatalystGResponse } from 'zcatalyst-sdk-node/lib/utils/pojo/common';
type ICatalystCacheRes = ICatalystCache & Omit<ICatalystGResponse, 'created_time' | 'created_by' | 'modified_time' | 'modified_by'>;
export declare class Connector {
    connectorName: string;
    private _authUrl;
    private _refreshUrl;
    private _refreshToken;
    private _clientId;
    private _clientSecret;
    expiresIn: number;
    expiresAt: number | null;
    private _redirectUrl;
    refreshIn: number;
    accessToken: null | string;
    private _connectionName;
    private app;
    private requester;
    constructor(connectionInstance: Connection, connectorDetails: {
        [x: string]: string;
    });
    get authUrl(): string;
    set authUrl(value: string);
    get refreshUrl(): string;
    set refreshUrl(value: string);
    get refreshToken(): string;
    set refreshToken(value: string);
    get clientId(): string;
    set clientId(value: string);
    get clientSecret(): string;
    set clientSecret(value: string);
    get redirectUrl(): string;
    set redirectUrl(value: string);
    /**
     * Calculates a hash based on all connector configuration parameters.
     * This ensures that any change in refresh token, client credentials, or URLs
     * results in a new cache key, preventing stale access tokens from being served.
     * Uses polynomial rolling hash (base 31) to generate a deterministic hash converted to
     * a 5-digit hexadecimal string. This provides a good balance between uniqueness and brevity for cache keys.
     */
    private getConnectorHash;
    private get _connectorName();
    getAccessToken(): Promise<string>;
    generateAccessToken(code: string): Promise<string>;
    refreshAndPersistToken(): Promise<string>;
    refreshAccessToken(): Promise<void>;
    putAccessTokenInCache(): Promise<ICatalystCacheRes>;
}
export {};
