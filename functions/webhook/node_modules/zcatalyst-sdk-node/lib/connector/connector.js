/* eslint-disable @typescript-eslint/no-explicit-any */
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connector = void 0;
const error_1 = require("../utils/error");
const validator_1 = require("../utils/validator");
const constants_1 = __importDefault(require("../utils/constants"));
const { CONNECTOR_NAME, AUTH_URL, REFRESH_URL, ACCESS_TOKEN, REFRESH_TOKEN, CLIENT_ID, CLIENT_SECRET, EXPIRES_IN, REFRESH_IN, REDIRECT_URL, GRANT_TYPE, CODE, REQ_METHOD } = constants_1.default;
class Connector {
    constructor(connectionInstance, connectorDetails) {
        this.connectorName = connectorDetails[CONNECTOR_NAME];
        this._authUrl = connectorDetails[AUTH_URL];
        this._refreshUrl = connectorDetails[REFRESH_URL];
        this._refreshToken = connectorDetails[REFRESH_TOKEN];
        this._clientId = connectorDetails[CLIENT_ID];
        this._clientSecret = connectorDetails[CLIENT_SECRET];
        this.expiresIn = parseInt(connectorDetails[EXPIRES_IN]);
        this.refreshIn = parseInt(connectorDetails[REFRESH_IN]) * 1000;
        this._redirectUrl = connectorDetails[REDIRECT_URL];
        this.accessToken = null;
        this.expiresAt = null;
        this._connectionName = null;
        this.app = connectionInstance.app;
        this.requester = connectionInstance.requester;
    }
    get authUrl() {
        return this._authUrl;
    }
    set authUrl(value) {
        this._authUrl = value;
        this._connectionName = null;
    }
    get refreshUrl() {
        return this._refreshUrl;
    }
    set refreshUrl(value) {
        this._refreshUrl = value;
        this._connectionName = null;
    }
    get refreshToken() {
        return this._refreshToken;
    }
    set refreshToken(value) {
        this._refreshToken = value;
        this._connectionName = null;
    }
    get clientId() {
        return this._clientId;
    }
    set clientId(value) {
        this._clientId = value;
        this._connectionName = null;
    }
    get clientSecret() {
        return this._clientSecret;
    }
    set clientSecret(value) {
        this._clientSecret = value;
        this._connectionName = null;
    }
    get redirectUrl() {
        return this._redirectUrl;
    }
    set redirectUrl(value) {
        this._redirectUrl = value;
        this._connectionName = null;
    }
    /**
     * Calculates a hash based on all connector configuration parameters.
     * This ensures that any change in refresh token, client credentials, or URLs
     * results in a new cache key, preventing stale access tokens from being served.
     * Uses polynomial rolling hash (base 31) to generate a deterministic hash converted to
     * a 5-digit hexadecimal string. This provides a good balance between uniqueness and brevity for cache keys.
     */
    getConnectorHash() {
        const configStr = [
            this.refreshToken,
            this.clientId,
            this.clientSecret,
            this.authUrl,
            this.refreshUrl,
            this.redirectUrl
        ]
            .filter((config) => config)
            .join(':');
        let strHash = 0;
        for (let i = 0; i < configStr.length; i++) {
            strHash = (strHash * 31 + configStr.charCodeAt(i)) | 0;
        }
        const hash = (31 + strHash) | 0;
        const masked = (hash >>> 0) & 0xfffff; // 20-bit or 5-digit hex
        return masked.toString(16).padStart(5, '0').toLowerCase();
    }
    get _connectorName() {
        if (this._connectionName === null) {
            this._connectionName = 'ZC_CONN_' + this.connectorName + ':' + this.getConnectorHash();
        }
        return this._connectionName;
    }
    getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.accessToken && this.expiresAt && Date.now() < this.expiresAt) {
                return this.accessToken;
            }
            const cachedTokenObj = yield this.app.cache().segment().get(this._connectorName);
            if (!(cachedTokenObj === null || cachedTokenObj === void 0 ? void 0 : cachedTokenObj.cache_value)) {
                return yield this.refreshAndPersistToken();
            }
            try {
                const value = JSON.parse(cachedTokenObj.cache_value);
                if (!(value === null || value === void 0 ? void 0 : value.access_token)) {
                    return yield this.refreshAndPersistToken();
                }
                const expiryTime = value.expires_at;
                if (expiryTime < Date.now()) {
                    return yield this.refreshAndPersistToken();
                }
                this.expiresAt = expiryTime;
                this.accessToken = value.access_token;
                return this.accessToken;
            }
            catch (err) {
                if (err instanceof SyntaxError)
                    return yield this.refreshAndPersistToken();
                throw err;
            }
        });
    }
    generateAccessToken(code) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(code, 'grant_token', true);
                (0, validator_1.isNonEmptyString)(this.redirectUrl, REDIRECT_URL, true);
            }, error_1.CatalystConnectorError);
            const request = {
                method: REQ_METHOD.post,
                url: this.authUrl,
                data: {
                    [GRANT_TYPE]: 'authorization_code',
                    [CODE]: code,
                    [CLIENT_ID]: this.clientId,
                    [CLIENT_SECRET]: this.clientSecret,
                    [REDIRECT_URL]: this.redirectUrl
                },
                catalyst: false
            };
            const resp = yield this.requester.send(request);
            const tokenObj = resp.data;
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonNullObject)(tokenObj, 'auth_response', true);
                (0, validator_1.ObjectHasProperties)(tokenObj, [ACCESS_TOKEN, REFRESH_TOKEN, EXPIRES_IN], 'auth_response', true);
            }, error_1.CatalystConnectorError);
            this.accessToken = tokenObj[ACCESS_TOKEN];
            this.refreshToken = tokenObj[REFRESH_TOKEN];
            this.expiresIn = parseInt(tokenObj[EXPIRES_IN]);
            const expires = Date.now() + (this.expiresIn * 1000 - 900000); // covert expiryIn(var) seconds to milliseconds and subtract 15 mins
            this.expiresAt = this.refreshIn ? Date.now() + this.refreshIn * 1000 : expires;
            yield this.putAccessTokenInCache();
            return this.accessToken;
        });
    }
    refreshAndPersistToken() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.refreshAccessToken();
            yield this.putAccessTokenInCache();
            return this.accessToken;
        });
    }
    refreshAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonEmptyString)(this.refreshToken, 'refresh_token', true);
                (0, validator_1.isNonEmptyString)(this.refreshUrl, 'refresh_url', true);
            }, error_1.CatalystConnectorError);
            const request = {
                method: REQ_METHOD.post,
                url: this.refreshUrl,
                data: {
                    [GRANT_TYPE]: 'refresh_token',
                    [CLIENT_ID]: this.clientId,
                    [CLIENT_SECRET]: this.clientSecret,
                    [REFRESH_TOKEN]: this.refreshToken
                },
                catalyst: false
            };
            const resp = yield this.requester.send(request);
            const tokenObject = resp.data;
            yield (0, validator_1.wrapValidatorsWithPromise)(() => {
                (0, validator_1.isNonNullObject)(tokenObject, 'auth_response', true);
                (0, validator_1.ObjectHasProperties)(tokenObject, [ACCESS_TOKEN, EXPIRES_IN], 'auth_response', true);
            }, error_1.CatalystConnectorError);
            this.accessToken = tokenObject[ACCESS_TOKEN];
            this.expiresIn = parseInt(tokenObject[EXPIRES_IN]);
            const expires = Date.now() + (this.expiresIn * 1000 - 900000);
            this.expiresAt = this.refreshIn ? Date.now() + this.refreshIn * 1000 : expires;
        });
    }
    putAccessTokenInCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenObj = {
                access_token: this.accessToken,
                expiry_in_seconds: this.expiresIn,
                expires_at: this.expiresAt
            };
            const tokenStr = JSON.stringify(tokenObj);
            return this.app
                .cache()
                .segment()
                .put(this._connectorName, tokenStr, Math.ceil(this.expiresIn / 3600));
        });
    }
}
exports.Connector = Connector;
